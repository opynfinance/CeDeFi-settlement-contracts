// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.13;

// interface
import {IERC20} from "@openzeppelin/token/ERC20/IERC20.sol";
// contract
import {EIP712} from "@openzeppelin/utils/cryptography/draft-EIP712.sol";
// lib
import {Counters} from "@openzeppelin/utils/Counters.sol";
import {ECDSA} from "@openzeppelin/utils/cryptography/ECDSA.sol";

/// @title Settlement
/// @author Haythem Sellami
contract Settlement is EIP712 {
    using Counters for Counters.Counter;

    bytes32 private constant _OPYN_RFQ_TYPEHASH =
        keccak256(
            "OpynRfq(uint256 offerId, uint256 bidId, address signerAddress, address bidderAddress, address bidToken, address offerToken, uint256 bidAmount, uint256 sellAmount, uint256 nonce)"
        );

    uint256 public offersCounter;

    mapping(address => address) public bidderDelegator; // mapping between bidder address and delegator that can sign bid in place of bidder
    mapping(uint256 => OfferData) public _offers;
    mapping(address => Counters.Counter) private _nonces;

    struct BidData {
        uint256 offerId; // the ID of offer this bid relate to
        uint256 bidId; // bidId generated by paradigmco
        address signerAddress; // bid signer address (can be different than bidder address if this address is a bidder delegator)
        address bidderAddress; // bidder address (can be different than signer address if bidder authorize signer address is it is delegator)
        address bidToken; // bid token address
        address offerToken; // offer token address
        uint256 bidAmount; // bid amount to buy from offer
        uint256 sellAmount; // amount to sell of bidToken
        uint8 v; // v
        bytes32 r; // r
        bytes32 s; // s
    }

    struct OfferData {
        address seller; // seller address
        address offerToken; // offer token to sell
        address bidToken; // accepted token to bid with
        uint128 minPrice; // price of 1 offerToken demnominated in bidToken
        uint128 minBidSize; // min bid size
        uint256 totalSize; // offer total size
    }

    event CreateOffer(
        uint256 indexed offerId,
        address indexed seller,
        address indexed offerToken,
        address bidToken,
        uint128 minPrice,
        uint128 minBidSize,
        uint256 totalSize
    );

    constructor(string memory _version) EIP712("OPYN RFQ", _version) {}

    function createOffer(
        address _offerToken,
        address _bidToken,
        uint128 _minPrice,
        uint128 _minBidSize,
        uint256 _totalSize
    ) external returns (uint256) {
        require(_minPrice > 0, "Invalid minPrice");
        require(_minBidSize > 0, "Invalid minBidSize");

        uint256 offerId = offersCounter += 1;

        _offers[offerId].seller = msg.sender;
        _offers[offerId].offerToken = _offerToken;
        _offers[offerId].bidToken = _bidToken;
        _offers[offerId].minPrice = _minPrice;
        _offers[offerId].minBidSize = _minBidSize;
        _offers[offerId].totalSize = _totalSize;

        emit CreateOffer(
            offerId,
            msg.sender,
            _offerToken,
            _bidToken,
            _minPrice,
            _minBidSize,
            _totalSize
        );

        return offerId;
    }

    function delegateToSigner(address _signer) external {
        require(_signer != address(0), "Invalid signer address");

        bidderDelegator[msg.sender] = _signer;
    }

    function settleOffer(uint256 _offerId, BidData calldata _bidData) external {
        require(
            _offers[_offerId].seller == msg.sender,
            "Not authorized to settle"
        );
        require(
            (_offerId == _bidData.offerId) &&
                (_bidData.bidToken == _offers[_offerId].bidToken) &&
                (_bidData.offerToken == _offers[_offerId].offerToken) &&
                (_bidData.bidAmount >= _offers[_offerId].minBidSize),
            "Offer details do not match"
        );

        if (_bidData.bidderAddress != _bidData.signerAddress) {
            // check that signer was delegated by bidder to sign
            require(
                bidderDelegator[_bidData.bidderAddress] ==
                    _bidData.signerAddress,
                "Invalid signer for bidder address"
            );
        }

        // verify big signature
        bytes32 structHash = keccak256(
            abi.encode(
                _OPYN_RFQ_TYPEHASH,
                _bidData.offerId,
                _bidData.bidId,
                _bidData.signerAddress,
                _bidData.bidderAddress,
                _bidData.bidToken,
                _bidData.offerToken,
                _bidData.bidAmount,
                _bidData.sellAmount,
                _useNonce(_bidData.signerAddress)
            )
        );
        bytes32 hash = _hashTypedDataV4(structHash);
        address bidSigner = ECDSA.recover(
            hash,
            _bidData.v,
            _bidData.r,
            _bidData.s
        );
        require(bidSigner == _bidData.signerAddress, "Invalid bid signature");

        IERC20(_bidData.offerToken).transferFrom(
            msg.sender,
            _bidData.bidderAddress,
            _bidData.bidAmount
        );
        IERC20(_bidData.bidToken).transferFrom(
            _bidData.bidderAddress,
            msg.sender,
            _bidData.sellAmount
        );
    }

    function nonces(address owner) external view returns (uint256) {
        return _nonces[owner].current();
    }

    function getOfferDetails(uint256 _offerId)
        external
        view
        returns (
            address,
            address,
            address,
            uint128,
            uint128
        )
    {
        OfferData memory offer = _offers[_offerId];

        return (
            offer.seller,
            offer.offerToken,
            offer.bidToken,
            offer.minPrice,
            offer.minBidSize
        );
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparatorV4();
    }

    function _useNonce(address owner) internal returns (uint256 current) {
        Counters.Counter storage nonce = _nonces[owner];
        current = nonce.current();
        nonce.increment();
    }
}
